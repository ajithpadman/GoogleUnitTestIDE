        -:    0:Source:D:/UnitTestDemo/GtestIncludes/gmock/gmock-actions.h
        -:    0:Graph:Mock_DemoMock.gcno
        -:    0:Data:Mock_DemoMock.gcda
        -:    0:Runs:15
        -:    0:Programs:1
        -:    1:// Copyright 2007, Google Inc.
        -:    2:// All rights reserved.
        -:    3://
        -:    4:// Redistribution and use in source and binary forms, with or without
        -:    5:// modification, are permitted provided that the following conditions are
        -:    6:// met:
        -:    7://
        -:    8://     * Redistributions of source code must retain the above copyright
        -:    9:// notice, this list of conditions and the following disclaimer.
        -:   10://     * Redistributions in binary form must reproduce the above
        -:   11:// copyright notice, this list of conditions and the following disclaimer
        -:   12:// in the documentation and/or other materials provided with the
        -:   13:// distribution.
        -:   14://     * Neither the name of Google Inc. nor the names of its
        -:   15:// contributors may be used to endorse or promote products derived from
        -:   16:// this software without specific prior written permission.
        -:   17://
        -:   18:// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   19:// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   20:// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   21:// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   22:// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   23:// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   24:// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   25:// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   26:// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   27:// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   28:// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   29://
        -:   30:// Author: wan@google.com (Zhanyong Wan)
        -:   31:
        -:   32:// Google Mock - a framework for writing C++ mock classes.
        -:   33://
        -:   34:// This file implements some commonly used actions.
        -:   35:
        -:   36:#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
        -:   37:#define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
        -:   38:
        -:   39:#ifndef _WIN32_WCE
        -:   40:# include <errno.h>
        -:   41:#endif
        -:   42:
        -:   43:#include <algorithm>
        -:   44:#include <string>
        -:   45:
        -:   46:#include "gmock/internal/gmock-internal-utils.h"
        -:   47:#include "gmock/internal/gmock-port.h"
        -:   48:
        -:   49:namespace testing {
        -:   50:
        -:   51:// To implement an action Foo, define:
        -:   52://   1. a class FooAction that implements the ActionInterface interface, and
        -:   53://   2. a factory function that creates an Action object from a
        -:   54://      const FooAction*.
        -:   55://
        -:   56:// The two-level delegation design follows that of Matcher, providing
        -:   57:// consistency for extension developers.  It also eases ownership
        -:   58:// management as Action objects can now be copied like plain values.
        -:   59:
        -:   60:namespace internal {
        -:   61:
        -:   62:template <typename F1, typename F2>
        -:   63:class ActionAdaptor;
        -:   64:
        -:   65:// BuiltInDefaultValue<T>::Get() returns the "built-in" default
        -:   66:// value for type T, which is NULL when T is a pointer type, 0 when T
        -:   67:// is a numeric type, false when T is bool, or "" when T is string or
        -:   68:// std::string.  For any other type T, this value is undefined and the
        -:   69:// function will abort the process.
        -:   70:template <typename T>
        -:   71:class BuiltInDefaultValue {
        -:   72: public:
        -:   73:  // This function returns true iff type T has a built-in default value.
        -:   74:  static bool Exists() { return false; }
        -:   75:  static T Get() {
        -:   76:    Assert(false, __FILE__, __LINE__,
        -:   77:           "Default action undefined for the function return type.");
        -:   78:    return internal::Invalid<T>();
        -:   79:    // The above statement will never be reached, but is required in
        -:   80:    // order for this function to compile.
        -:   81:  }
        -:   82:};
        -:   83:
        -:   84:// This partial specialization says that we use the same built-in
        -:   85:// default value for T and const T.
        -:   86:template <typename T>
        -:   87:class BuiltInDefaultValue<const T> {
        -:   88: public:
        -:   89:  static bool Exists() { return BuiltInDefaultValue<T>::Exists(); }
        -:   90:  static T Get() { return BuiltInDefaultValue<T>::Get(); }
        -:   91:};
        -:   92:
        -:   93:// This partial specialization defines the default values for pointer
        -:   94:// types.
        -:   95:template <typename T>
        -:   96:class BuiltInDefaultValue<T*> {
        -:   97: public:
        -:   98:  static bool Exists() { return true; }
        -:   99:  static T* Get() { return NULL; }
        -:  100:};
        -:  101:
        -:  102:// The following specializations define the default values for
        -:  103:// specific types we care about.
        -:  104:#define GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(type, value) \
        -:  105:  template <> \
        -:  106:  class BuiltInDefaultValue<type> { \
        -:  107:   public: \
        -:  108:    static bool Exists() { return true; } \
        -:  109:    static type Get() { return value; } \
        -:  110:  }
        -:  111:
        -:  112:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(void, );  // NOLINT
        -:  113:#if GTEST_HAS_GLOBAL_STRING
        -:  114:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::string, "");
        -:  115:#endif  // GTEST_HAS_GLOBAL_STRING
        -:  116:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::std::string, "");
        -:  117:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(bool, false);
    #####:  118:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned char, '\0');
        -:  119:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed char, '\0');
        -:  120:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(char, '\0');
        -:  121:
        -:  122:// There's no need for a default action for signed wchar_t, as that
        -:  123:// type is the same as wchar_t for gcc, and invalid for MSVC.
        -:  124://
        -:  125:// There's also no need for a default action for unsigned wchar_t, as
        -:  126:// that type is the same as unsigned int for gcc, and invalid for
        -:  127:// MSVC.
        -:  128:#if GMOCK_WCHAR_T_IS_NATIVE_
        -:  129:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(wchar_t, 0U);  // NOLINT
        -:  130:#endif
        -:  131:
        -:  132:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned short, 0U);  // NOLINT
        -:  133:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed short, 0);     // NOLINT
        -:  134:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned int, 0U);
        -:  135:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed int, 0);
        -:  136:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long, 0UL);  // NOLINT
        -:  137:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long, 0L);     // NOLINT
        -:  138:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(UInt64, 0);
        -:  139:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(Int64, 0);
        -:  140:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(float, 0);
        -:  141:GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(double, 0);
        -:  142:
        -:  143:#undef GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_
        -:  144:
        -:  145:}  // namespace internal
        -:  146:
        -:  147:// When an unexpected function call is encountered, Google Mock will
        -:  148:// let it return a default value if the user has specified one for its
        -:  149:// return type, or if the return type has a built-in default value;
        -:  150:// otherwise Google Mock won't know what value to return and will have
        -:  151:// to abort the process.
        -:  152://
        -:  153:// The DefaultValue<T> class allows a user to specify the
        -:  154:// default value for a type T that is both copyable and publicly
        -:  155:// destructible (i.e. anything that can be used as a function return
        -:  156:// type).  The usage is:
        -:  157://
        -:  158://   // Sets the default value for type T to be foo.
        -:  159://   DefaultValue<T>::Set(foo);
        -:  160:template <typename T>
        -:  161:class DefaultValue {
        -:  162: public:
        -:  163:  // Sets the default value for type T; requires T to be
        -:  164:  // copy-constructable and have a public destructor.
        -:  165:  static void Set(T x) {
        -:  166:    delete value_;
        -:  167:    value_ = new T(x);
        -:  168:  }
        -:  169:
        -:  170:  // Unsets the default value for type T.
        -:  171:  static void Clear() {
        -:  172:    delete value_;
        -:  173:    value_ = NULL;
        -:  174:  }
        -:  175:
        -:  176:  // Returns true iff the user has set the default value for type T.
    #####:  177:  static bool IsSet() { return value_ != NULL; }
        -:  178:
        -:  179:  // Returns true if T has a default return value set by the user or there
        -:  180:  // exists a built-in default value.
    #####:  181:  static bool Exists() {
    #####:  182:    return IsSet() || internal::BuiltInDefaultValue<T>::Exists();
        -:  183:  }
        -:  184:
        -:  185:  // Returns the default value for type T if the user has set one;
        -:  186:  // otherwise returns the built-in default value if there is one;
        -:  187:  // otherwise aborts the process.
    #####:  188:  static T Get() {
        -:  189:    return value_ == NULL ?
    #####:  190:        internal::BuiltInDefaultValue<T>::Get() : *value_;
        -:  191:  }
        -:  192:
        -:  193: private:
        -:  194:  static const T* value_;
        -:  195:};
        -:  196:
        -:  197:// This partial specialization allows a user to set default values for
        -:  198:// reference types.
        -:  199:template <typename T>
        -:  200:class DefaultValue<T&> {
        -:  201: public:
        -:  202:  // Sets the default value for type T&.
        -:  203:  static void Set(T& x) {  // NOLINT
        -:  204:    address_ = &x;
        -:  205:  }
        -:  206:
        -:  207:  // Unsets the default value for type T&.
        -:  208:  static void Clear() {
        -:  209:    address_ = NULL;
        -:  210:  }
        -:  211:
        -:  212:  // Returns true iff the user has set the default value for type T&.
        -:  213:  static bool IsSet() { return address_ != NULL; }
        -:  214:
        -:  215:  // Returns true if T has a default return value set by the user or there
        -:  216:  // exists a built-in default value.
        -:  217:  static bool Exists() {
        -:  218:    return IsSet() || internal::BuiltInDefaultValue<T&>::Exists();
        -:  219:  }
        -:  220:
        -:  221:  // Returns the default value for type T& if the user has set one;
        -:  222:  // otherwise returns the built-in default value if there is one;
        -:  223:  // otherwise aborts the process.
        -:  224:  static T& Get() {
        -:  225:    return address_ == NULL ?
        -:  226:        internal::BuiltInDefaultValue<T&>::Get() : *address_;
        -:  227:  }
        -:  228:
        -:  229: private:
        -:  230:  static T* address_;
        -:  231:};
        -:  232:
        -:  233:// This specialization allows DefaultValue<void>::Get() to
        -:  234:// compile.
        -:  235:template <>
        -:  236:class DefaultValue<void> {
        -:  237: public:
        2:  238:  static bool Exists() { return true; }
        2:  239:  static void Get() {}
        -:  240:};
        -:  241:
        -:  242:// Points to the user-set default value for type T.
        -:  243:template <typename T>
        -:  244:const T* DefaultValue<T>::value_ = NULL;
        -:  245:
        -:  246:// Points to the user-set default value for type T&.
        -:  247:template <typename T>
        -:  248:T* DefaultValue<T&>::address_ = NULL;
        -:  249:
        -:  250:// Implement this interface to define an action for function type F.
        -:  251:template <typename F>
        -:  252:class ActionInterface {
        -:  253: public:
        -:  254:  typedef typename internal::Function<F>::Result Result;
        -:  255:  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;
        -:  256:
       12:  257:  ActionInterface() {}
       12:  258:  virtual ~ActionInterface() {}
        -:  259:
        -:  260:  // Performs the action.  This method is not const, as in general an
        -:  261:  // action can have side effects and be stateful.  For example, a
        -:  262:  // get-the-next-element-from-the-collection action will need to
        -:  263:  // remember the current element.
        -:  264:  virtual Result Perform(const ArgumentTuple& args) = 0;
        -:  265:
        -:  266: private:
        -:  267:  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionInterface);
        -:  268:};
        -:  269:
        -:  270:// An Action<F> is a copyable and IMMUTABLE (except by assignment)
        -:  271:// object that represents an action to be taken when a mock function
        -:  272:// of type F is called.  The implementation of Action<T> is just a
        -:  273:// linked_ptr to const ActionInterface<T>, so copying is fairly cheap.
        -:  274:// Don't inherit from Action!
        -:  275://
        -:  276:// You can view an object implementing ActionInterface<F> as a
        -:  277:// concrete action (including its current state), and an Action<F>
        -:  278:// object as a handle to it.
        -:  279:template <typename F>
       48:  280:class Action {
        -:  281: public:
        -:  282:  typedef typename internal::Function<F>::Result Result;
        -:  283:  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;
        -:  284:
        -:  285:  // Constructs a null Action.  Needed for storing Action objects in
        -:  286:  // STL containers.
        -:  287:  Action() : impl_(NULL) {}
        -:  288:
        -:  289:  // Constructs an Action from its implementation.  A NULL impl is
        -:  290:  // used to represent the "do-default" action.
       24:  291:  explicit Action(ActionInterface<F>* impl) : impl_(impl) {}
        -:  292:
        -:  293:  // Copy constructor.
       12:  294:  Action(const Action& action) : impl_(action.impl_) {}
        -:  295:
        -:  296:  // This constructor allows us to turn an Action<Func> object into an
        -:  297:  // Action<F>, as long as F's arguments can be implicitly converted
        -:  298:  // to Func's and Func's return type can be implicitly converted to
        -:  299:  // F's.
        -:  300:  template <typename Func>
        -:  301:  explicit Action(const Action<Func>& action);
        -:  302:
        -:  303:  // Returns true iff this is the DoDefault() action.
       24:  304:  bool IsDoDefault() const { return impl_.get() == NULL; }
        -:  305:
        -:  306:  // Performs the action.  Note that this method is const even though
        -:  307:  // the corresponding method in ActionInterface is not.  The reason
        -:  308:  // is that a const Action<F> means that it cannot be re-bound to
        -:  309:  // another concrete action, not that the concrete action it binds to
        -:  310:  // cannot change state.  (Think of the difference between a const
        -:  311:  // pointer and a pointer to const.)
       12:  312:  Result Perform(const ArgumentTuple& args) const {
       12:  313:    internal::Assert(
        -:  314:        !IsDoDefault(), __FILE__, __LINE__,
        -:  315:        "You are using DoDefault() inside a composite action like "
        -:  316:        "DoAll() or WithArgs().  This is not supported for technical "
        -:  317:        "reasons.  Please instead spell out the default action, or "
        -:  318:        "assign the default action to an Action variable and use "
        -:  319:        "the variable in various places.");
       12:  320:    return impl_->Perform(args);
        -:  321:  }
        -:  322:
        -:  323: private:
        -:  324:  template <typename F1, typename F2>
        -:  325:  friend class internal::ActionAdaptor;
        -:  326:
        -:  327:  internal::linked_ptr<ActionInterface<F> > impl_;
        -:  328:};
        -:  329:
        -:  330:// The PolymorphicAction class template makes it easy to implement a
        -:  331:// polymorphic action (i.e. an action that can be used in mock
        -:  332:// functions of than one type, e.g. Return()).
        -:  333://
        -:  334:// To define a polymorphic action, a user first provides a COPYABLE
        -:  335:// implementation class that has a Perform() method template:
        -:  336://
        -:  337://   class FooAction {
        -:  338://    public:
        -:  339://     template <typename Result, typename ArgumentTuple>
        -:  340://     Result Perform(const ArgumentTuple& args) const {
        -:  341://       // Processes the arguments and returns a result, using
        -:  342://       // tr1::get<N>(args) to get the N-th (0-based) argument in the tuple.
        -:  343://     }
        -:  344://     ...
        -:  345://   };
        -:  346://
        -:  347:// Then the user creates the polymorphic action using
        -:  348:// MakePolymorphicAction(object) where object has type FooAction.  See
        -:  349:// the definition of Return(void) and SetArgumentPointee<N>(value) for
        -:  350:// complete examples.
        -:  351:template <typename Impl>
        -:  352:class PolymorphicAction {
        -:  353: public:
        -:  354:  explicit PolymorphicAction(const Impl& impl) : impl_(impl) {}
        -:  355:
        -:  356:  template <typename F>
        -:  357:  operator Action<F>() const {
        -:  358:    return Action<F>(new MonomorphicImpl<F>(impl_));
        -:  359:  }
        -:  360:
        -:  361: private:
        -:  362:  template <typename F>
        -:  363:  class MonomorphicImpl : public ActionInterface<F> {
        -:  364:   public:
        -:  365:    typedef typename internal::Function<F>::Result Result;
        -:  366:    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;
        -:  367:
        -:  368:    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}
        -:  369:
        -:  370:    virtual Result Perform(const ArgumentTuple& args) {
        -:  371:      return impl_.template Perform<Result>(args);
        -:  372:    }
        -:  373:
        -:  374:   private:
        -:  375:    Impl impl_;
        -:  376:
        -:  377:    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);
        -:  378:  };
        -:  379:
        -:  380:  Impl impl_;
        -:  381:
        -:  382:  GTEST_DISALLOW_ASSIGN_(PolymorphicAction);
        -:  383:};
        -:  384:
        -:  385:// Creates an Action from its implementation and returns it.  The
        -:  386:// created Action object owns the implementation.
        -:  387:template <typename F>
        -:  388:Action<F> MakeAction(ActionInterface<F>* impl) {
        -:  389:  return Action<F>(impl);
        -:  390:}
        -:  391:
        -:  392:// Creates a polymorphic action from its implementation.  This is
        -:  393:// easier to use than the PolymorphicAction<Impl> constructor as it
        -:  394:// doesn't require you to explicitly write the template argument, e.g.
        -:  395://
        -:  396://   MakePolymorphicAction(foo);
        -:  397:// vs
        -:  398://   PolymorphicAction<TypeOfFoo>(foo);
        -:  399:template <typename Impl>
        -:  400:inline PolymorphicAction<Impl> MakePolymorphicAction(const Impl& impl) {
        -:  401:  return PolymorphicAction<Impl>(impl);
        -:  402:}
        -:  403:
        -:  404:namespace internal {
        -:  405:
        -:  406:// Allows an Action<F2> object to pose as an Action<F1>, as long as F2
        -:  407:// and F1 are compatible.
        -:  408:template <typename F1, typename F2>
        -:  409:class ActionAdaptor : public ActionInterface<F1> {
        -:  410: public:
        -:  411:  typedef typename internal::Function<F1>::Result Result;
        -:  412:  typedef typename internal::Function<F1>::ArgumentTuple ArgumentTuple;
        -:  413:
        -:  414:  explicit ActionAdaptor(const Action<F2>& from) : impl_(from.impl_) {}
        -:  415:
        -:  416:  virtual Result Perform(const ArgumentTuple& args) {
        -:  417:    return impl_->Perform(args);
        -:  418:  }
        -:  419:
        -:  420: private:
        -:  421:  const internal::linked_ptr<ActionInterface<F2> > impl_;
        -:  422:
        -:  423:  GTEST_DISALLOW_ASSIGN_(ActionAdaptor);
        -:  424:};
        -:  425:
        -:  426:// Implements the polymorphic Return(x) action, which can be used in
        -:  427:// any function that returns the type of x, regardless of the argument
        -:  428:// types.
        -:  429://
        -:  430:// Note: The value passed into Return must be converted into
        -:  431:// Function<F>::Result when this action is cast to Action<F> rather than
        -:  432:// when that action is performed. This is important in scenarios like
        -:  433://
        -:  434:// MOCK_METHOD1(Method, T(U));
        -:  435:// ...
        -:  436:// {
        -:  437://   Foo foo;
        -:  438://   X x(&foo);
        -:  439://   EXPECT_CALL(mock, Method(_)).WillOnce(Return(x));
        -:  440:// }
        -:  441://
        -:  442:// In the example above the variable x holds reference to foo which leaves
        -:  443:// scope and gets destroyed.  If copying X just copies a reference to foo,
        -:  444:// that copy will be left with a hanging reference.  If conversion to T
        -:  445:// makes a copy of foo, the above code is safe. To support that scenario, we
        -:  446:// need to make sure that the type conversion happens inside the EXPECT_CALL
        -:  447:// statement, and conversion of the result of Return to Action<T(U)> is a
        -:  448:// good place for that.
        -:  449://
        -:  450:template <typename R>
        -:  451:class ReturnAction {
        -:  452: public:
        -:  453:  // Constructs a ReturnAction object from the value to be returned.
        -:  454:  // 'value' is passed by value instead of by const reference in order
        -:  455:  // to allow Return("string literal") to compile.
       12:  456:  explicit ReturnAction(R value) : value_(value) {}
        -:  457:
        -:  458:  // This template type conversion operator allows Return(x) to be
        -:  459:  // used in ANY function that returns x's type.
        -:  460:  template <typename F>
       12:  461:  operator Action<F>() const {
        -:  462:    // Assert statement belongs here because this is the best place to verify
        -:  463:    // conditions on F. It produces the clearest error messages
        -:  464:    // in most compilers.
        -:  465:    // Impl really belongs in this scope as a local class but can't
        -:  466:    // because MSVC produces duplicate symbols in different translation units
        -:  467:    // in this case. Until MS fixes that bug we put Impl into the class scope
        -:  468:    // and put the typedef both here (for use in assert statement) and
        -:  469:    // in the Impl class. But both definitions must be the same.
        -:  470:    typedef typename Function<F>::Result Result;
        -:  471:    GTEST_COMPILE_ASSERT_(
        -:  472:        !internal::is_reference<Result>::value,
        -:  473:        use_ReturnRef_instead_of_Return_to_return_a_reference);
       12:  474:    return Action<F>(new Impl<F>(value_));
        -:  475:  }
        -:  476:
        -:  477: private:
        -:  478:  // Implements the Return(x) action for a particular function type F.
        -:  479:  template <typename F>
       24:  480:  class Impl : public ActionInterface<F> {
        -:  481:   public:
        -:  482:    typedef typename Function<F>::Result Result;
        -:  483:    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
        -:  484:
        -:  485:    // The implicit cast is necessary when Result has more than one
        -:  486:    // single-argument constructor (e.g. Result is std::vector<int>) and R
        -:  487:    // has a type conversion operator template.  In that case, value_(value)
        -:  488:    // won't compile as the compiler doesn't known which constructor of
        -:  489:    // Result to call.  ImplicitCast_ forces the compiler to convert R to
        -:  490:    // Result without considering explicit constructors, thus resolving the
        -:  491:    // ambiguity. value_ is then initialized using its copy constructor.
       12:  492:    explicit Impl(R value)
       12:  493:        : value_(::testing::internal::ImplicitCast_<Result>(value)) {}
        -:  494:
       12:  495:    virtual Result Perform(const ArgumentTuple&) { return value_; }
        -:  496:
        -:  497:   private:
        -:  498:    GTEST_COMPILE_ASSERT_(!internal::is_reference<Result>::value,
        -:  499:                          Result_cannot_be_a_reference_type);
        -:  500:    Result value_;
        -:  501:
        -:  502:    GTEST_DISALLOW_ASSIGN_(Impl);
        -:  503:  };
        -:  504:
        -:  505:  R value_;
        -:  506:
        -:  507:  GTEST_DISALLOW_ASSIGN_(ReturnAction);
        -:  508:};
        -:  509:
        -:  510:// Implements the ReturnNull() action.
        -:  511:class ReturnNullAction {
        -:  512: public:
        -:  513:  // Allows ReturnNull() to be used in any pointer-returning function.
        -:  514:  template <typename Result, typename ArgumentTuple>
        -:  515:  static Result Perform(const ArgumentTuple&) {
        -:  516:    GTEST_COMPILE_ASSERT_(internal::is_pointer<Result>::value,
        -:  517:                          ReturnNull_can_be_used_to_return_a_pointer_only);
        -:  518:    return NULL;
        -:  519:  }
        -:  520:};
        -:  521:
        -:  522:// Implements the Return() action.
        -:  523:class ReturnVoidAction {
        -:  524: public:
        -:  525:  // Allows Return() to be used in any void-returning function.
        -:  526:  template <typename Result, typename ArgumentTuple>
        -:  527:  static void Perform(const ArgumentTuple&) {
        -:  528:    CompileAssertTypesEqual<void, Result>();
        -:  529:  }
        -:  530:};
        -:  531:
        -:  532:// Implements the polymorphic ReturnRef(x) action, which can be used
        -:  533:// in any function that returns a reference to the type of x,
        -:  534:// regardless of the argument types.
        -:  535:template <typename T>
        -:  536:class ReturnRefAction {
        -:  537: public:
        -:  538:  // Constructs a ReturnRefAction object from the reference to be returned.
        -:  539:  explicit ReturnRefAction(T& ref) : ref_(ref) {}  // NOLINT
        -:  540:
        -:  541:  // This template type conversion operator allows ReturnRef(x) to be
        -:  542:  // used in ANY function that returns a reference to x's type.
        -:  543:  template <typename F>
        -:  544:  operator Action<F>() const {
        -:  545:    typedef typename Function<F>::Result Result;
        -:  546:    // Asserts that the function return type is a reference.  This
        -:  547:    // catches the user error of using ReturnRef(x) when Return(x)
        -:  548:    // should be used, and generates some helpful error message.
        -:  549:    GTEST_COMPILE_ASSERT_(internal::is_reference<Result>::value,
        -:  550:                          use_Return_instead_of_ReturnRef_to_return_a_value);
        -:  551:    return Action<F>(new Impl<F>(ref_));
        -:  552:  }
        -:  553:
        -:  554: private:
        -:  555:  // Implements the ReturnRef(x) action for a particular function type F.
        -:  556:  template <typename F>
        -:  557:  class Impl : public ActionInterface<F> {
        -:  558:   public:
        -:  559:    typedef typename Function<F>::Result Result;
        -:  560:    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
        -:  561:
        -:  562:    explicit Impl(T& ref) : ref_(ref) {}  // NOLINT
        -:  563:
        -:  564:    virtual Result Perform(const ArgumentTuple&) {
        -:  565:      return ref_;
        -:  566:    }
        -:  567:
        -:  568:   private:
        -:  569:    T& ref_;
        -:  570:
        -:  571:    GTEST_DISALLOW_ASSIGN_(Impl);
        -:  572:  };
        -:  573:
        -:  574:  T& ref_;
        -:  575:
        -:  576:  GTEST_DISALLOW_ASSIGN_(ReturnRefAction);
        -:  577:};
        -:  578:
        -:  579:// Implements the polymorphic ReturnRefOfCopy(x) action, which can be
        -:  580:// used in any function that returns a reference to the type of x,
        -:  581:// regardless of the argument types.
        -:  582:template <typename T>
        -:  583:class ReturnRefOfCopyAction {
        -:  584: public:
        -:  585:  // Constructs a ReturnRefOfCopyAction object from the reference to
        -:  586:  // be returned.
        -:  587:  explicit ReturnRefOfCopyAction(const T& value) : value_(value) {}  // NOLINT
        -:  588:
        -:  589:  // This template type conversion operator allows ReturnRefOfCopy(x) to be
        -:  590:  // used in ANY function that returns a reference to x's type.
        -:  591:  template <typename F>
        -:  592:  operator Action<F>() const {
        -:  593:    typedef typename Function<F>::Result Result;
        -:  594:    // Asserts that the function return type is a reference.  This
        -:  595:    // catches the user error of using ReturnRefOfCopy(x) when Return(x)
        -:  596:    // should be used, and generates some helpful error message.
        -:  597:    GTEST_COMPILE_ASSERT_(
        -:  598:        internal::is_reference<Result>::value,
        -:  599:        use_Return_instead_of_ReturnRefOfCopy_to_return_a_value);
        -:  600:    return Action<F>(new Impl<F>(value_));
        -:  601:  }
        -:  602:
        -:  603: private:
        -:  604:  // Implements the ReturnRefOfCopy(x) action for a particular function type F.
        -:  605:  template <typename F>
        -:  606:  class Impl : public ActionInterface<F> {
        -:  607:   public:
        -:  608:    typedef typename Function<F>::Result Result;
        -:  609:    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
        -:  610:
        -:  611:    explicit Impl(const T& value) : value_(value) {}  // NOLINT
        -:  612:
        -:  613:    virtual Result Perform(const ArgumentTuple&) {
        -:  614:      return value_;
        -:  615:    }
        -:  616:
        -:  617:   private:
        -:  618:    T value_;
        -:  619:
        -:  620:    GTEST_DISALLOW_ASSIGN_(Impl);
        -:  621:  };
        -:  622:
        -:  623:  const T value_;
        -:  624:
        -:  625:  GTEST_DISALLOW_ASSIGN_(ReturnRefOfCopyAction);
        -:  626:};
        -:  627:
        -:  628:// Implements the polymorphic DoDefault() action.
        -:  629:class DoDefaultAction {
        -:  630: public:
        -:  631:  // This template type conversion operator allows DoDefault() to be
        -:  632:  // used in any function.
        -:  633:  template <typename F>
       12:  634:  operator Action<F>() const { return Action<F>(NULL); }
        -:  635:};
        -:  636:
        -:  637:// Implements the Assign action to set a given pointer referent to a
        -:  638:// particular value.
        -:  639:template <typename T1, typename T2>
        -:  640:class AssignAction {
        -:  641: public:
        -:  642:  AssignAction(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}
        -:  643:
        -:  644:  template <typename Result, typename ArgumentTuple>
        -:  645:  void Perform(const ArgumentTuple& /* args */) const {
        -:  646:    *ptr_ = value_;
        -:  647:  }
        -:  648:
        -:  649: private:
        -:  650:  T1* const ptr_;
        -:  651:  const T2 value_;
        -:  652:
        -:  653:  GTEST_DISALLOW_ASSIGN_(AssignAction);
        -:  654:};
        -:  655:
        -:  656:#if !GTEST_OS_WINDOWS_MOBILE
        -:  657:
        -:  658:// Implements the SetErrnoAndReturn action to simulate return from
        -:  659:// various system calls and libc functions.
        -:  660:template <typename T>
        -:  661:class SetErrnoAndReturnAction {
        -:  662: public:
        -:  663:  SetErrnoAndReturnAction(int errno_value, T result)
        -:  664:      : errno_(errno_value),
        -:  665:        result_(result) {}
        -:  666:  template <typename Result, typename ArgumentTuple>
        -:  667:  Result Perform(const ArgumentTuple& /* args */) const {
        -:  668:    errno = errno_;
        -:  669:    return result_;
        -:  670:  }
        -:  671:
        -:  672: private:
        -:  673:  const int errno_;
        -:  674:  const T result_;
        -:  675:
        -:  676:  GTEST_DISALLOW_ASSIGN_(SetErrnoAndReturnAction);
        -:  677:};
        -:  678:
        -:  679:#endif  // !GTEST_OS_WINDOWS_MOBILE
        -:  680:
        -:  681:// Implements the SetArgumentPointee<N>(x) action for any function
        -:  682:// whose N-th argument (0-based) is a pointer to x's type.  The
        -:  683:// template parameter kIsProto is true iff type A is ProtocolMessage,
        -:  684:// proto2::Message, or a sub-class of those.
        -:  685:template <size_t N, typename A, bool kIsProto>
        -:  686:class SetArgumentPointeeAction {
        -:  687: public:
        -:  688:  // Constructs an action that sets the variable pointed to by the
        -:  689:  // N-th function argument to 'value'.
        -:  690:  explicit SetArgumentPointeeAction(const A& value) : value_(value) {}
        -:  691:
        -:  692:  template <typename Result, typename ArgumentTuple>
        -:  693:  void Perform(const ArgumentTuple& args) const {
        -:  694:    CompileAssertTypesEqual<void, Result>();
        -:  695:    *::std::tr1::get<N>(args) = value_;
        -:  696:  }
        -:  697:
        -:  698: private:
        -:  699:  const A value_;
        -:  700:
        -:  701:  GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);
        -:  702:};
        -:  703:
        -:  704:template <size_t N, typename Proto>
        -:  705:class SetArgumentPointeeAction<N, Proto, true> {
        -:  706: public:
        -:  707:  // Constructs an action that sets the variable pointed to by the
        -:  708:  // N-th function argument to 'proto'.  Both ProtocolMessage and
        -:  709:  // proto2::Message have the CopyFrom() method, so the same
        -:  710:  // implementation works for both.
        -:  711:  explicit SetArgumentPointeeAction(const Proto& proto) : proto_(new Proto) {
        -:  712:    proto_->CopyFrom(proto);
        -:  713:  }
        -:  714:
        -:  715:  template <typename Result, typename ArgumentTuple>
        -:  716:  void Perform(const ArgumentTuple& args) const {
        -:  717:    CompileAssertTypesEqual<void, Result>();
        -:  718:    ::std::tr1::get<N>(args)->CopyFrom(*proto_);
        -:  719:  }
        -:  720:
        -:  721: private:
        -:  722:  const internal::linked_ptr<Proto> proto_;
        -:  723:
        -:  724:  GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);
        -:  725:};
        -:  726:
        -:  727:// Implements the InvokeWithoutArgs(f) action.  The template argument
        -:  728:// FunctionImpl is the implementation type of f, which can be either a
        -:  729:// function pointer or a functor.  InvokeWithoutArgs(f) can be used as an
        -:  730:// Action<F> as long as f's type is compatible with F (i.e. f can be
        -:  731:// assigned to a tr1::function<F>).
        -:  732:template <typename FunctionImpl>
        -:  733:class InvokeWithoutArgsAction {
        -:  734: public:
        -:  735:  // The c'tor makes a copy of function_impl (either a function
        -:  736:  // pointer or a functor).
        -:  737:  explicit InvokeWithoutArgsAction(FunctionImpl function_impl)
        -:  738:      : function_impl_(function_impl) {}
        -:  739:
        -:  740:  // Allows InvokeWithoutArgs(f) to be used as any action whose type is
        -:  741:  // compatible with f.
        -:  742:  template <typename Result, typename ArgumentTuple>
        -:  743:  Result Perform(const ArgumentTuple&) { return function_impl_(); }
        -:  744:
        -:  745: private:
        -:  746:  FunctionImpl function_impl_;
        -:  747:
        -:  748:  GTEST_DISALLOW_ASSIGN_(InvokeWithoutArgsAction);
        -:  749:};
        -:  750:
        -:  751:// Implements the InvokeWithoutArgs(object_ptr, &Class::Method) action.
        -:  752:template <class Class, typename MethodPtr>
        -:  753:class InvokeMethodWithoutArgsAction {
        -:  754: public:
        -:  755:  InvokeMethodWithoutArgsAction(Class* obj_ptr, MethodPtr method_ptr)
        -:  756:      : obj_ptr_(obj_ptr), method_ptr_(method_ptr) {}
        -:  757:
        -:  758:  template <typename Result, typename ArgumentTuple>
        -:  759:  Result Perform(const ArgumentTuple&) const {
        -:  760:    return (obj_ptr_->*method_ptr_)();
        -:  761:  }
        -:  762:
        -:  763: private:
        -:  764:  Class* const obj_ptr_;
        -:  765:  const MethodPtr method_ptr_;
        -:  766:
        -:  767:  GTEST_DISALLOW_ASSIGN_(InvokeMethodWithoutArgsAction);
        -:  768:};
        -:  769:
        -:  770:// Implements the IgnoreResult(action) action.
        -:  771:template <typename A>
        -:  772:class IgnoreResultAction {
        -:  773: public:
        -:  774:  explicit IgnoreResultAction(const A& action) : action_(action) {}
        -:  775:
        -:  776:  template <typename F>
        -:  777:  operator Action<F>() const {
        -:  778:    // Assert statement belongs here because this is the best place to verify
        -:  779:    // conditions on F. It produces the clearest error messages
        -:  780:    // in most compilers.
        -:  781:    // Impl really belongs in this scope as a local class but can't
        -:  782:    // because MSVC produces duplicate symbols in different translation units
        -:  783:    // in this case. Until MS fixes that bug we put Impl into the class scope
        -:  784:    // and put the typedef both here (for use in assert statement) and
        -:  785:    // in the Impl class. But both definitions must be the same.
        -:  786:    typedef typename internal::Function<F>::Result Result;
        -:  787:
        -:  788:    // Asserts at compile time that F returns void.
        -:  789:    CompileAssertTypesEqual<void, Result>();
        -:  790:
        -:  791:    return Action<F>(new Impl<F>(action_));
        -:  792:  }
        -:  793:
        -:  794: private:
        -:  795:  template <typename F>
        -:  796:  class Impl : public ActionInterface<F> {
        -:  797:   public:
        -:  798:    typedef typename internal::Function<F>::Result Result;
        -:  799:    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;
        -:  800:
        -:  801:    explicit Impl(const A& action) : action_(action) {}
        -:  802:
        -:  803:    virtual void Perform(const ArgumentTuple& args) {
        -:  804:      // Performs the action and ignores its result.
        -:  805:      action_.Perform(args);
        -:  806:    }
        -:  807:
        -:  808:   private:
        -:  809:    // Type OriginalFunction is the same as F except that its return
        -:  810:    // type is IgnoredValue.
        -:  811:    typedef typename internal::Function<F>::MakeResultIgnoredValue
        -:  812:        OriginalFunction;
        -:  813:
        -:  814:    const Action<OriginalFunction> action_;
        -:  815:
        -:  816:    GTEST_DISALLOW_ASSIGN_(Impl);
        -:  817:  };
        -:  818:
        -:  819:  const A action_;
        -:  820:
        -:  821:  GTEST_DISALLOW_ASSIGN_(IgnoreResultAction);
        -:  822:};
        -:  823:
        -:  824:// A ReferenceWrapper<T> object represents a reference to type T,
        -:  825:// which can be either const or not.  It can be explicitly converted
        -:  826:// from, and implicitly converted to, a T&.  Unlike a reference,
        -:  827:// ReferenceWrapper<T> can be copied and can survive template type
        -:  828:// inference.  This is used to support by-reference arguments in the
        -:  829:// InvokeArgument<N>(...) action.  The idea was from "reference
        -:  830:// wrappers" in tr1, which we don't have in our source tree yet.
        -:  831:template <typename T>
        -:  832:class ReferenceWrapper {
        -:  833: public:
        -:  834:  // Constructs a ReferenceWrapper<T> object from a T&.
        -:  835:  explicit ReferenceWrapper(T& l_value) : pointer_(&l_value) {}  // NOLINT
        -:  836:
        -:  837:  // Allows a ReferenceWrapper<T> object to be implicitly converted to
        -:  838:  // a T&.
        -:  839:  operator T&() const { return *pointer_; }
        -:  840: private:
        -:  841:  T* pointer_;
        -:  842:};
        -:  843:
        -:  844:// Allows the expression ByRef(x) to be printed as a reference to x.
        -:  845:template <typename T>
        -:  846:void PrintTo(const ReferenceWrapper<T>& ref, ::std::ostream* os) {
        -:  847:  T& value = ref;
        -:  848:  UniversalPrinter<T&>::Print(value, os);
        -:  849:}
        -:  850:
        -:  851:// Does two actions sequentially.  Used for implementing the DoAll(a1,
        -:  852:// a2, ...) action.
        -:  853:template <typename Action1, typename Action2>
        -:  854:class DoBothAction {
        -:  855: public:
        -:  856:  DoBothAction(Action1 action1, Action2 action2)
        -:  857:      : action1_(action1), action2_(action2) {}
        -:  858:
        -:  859:  // This template type conversion operator allows DoAll(a1, ..., a_n)
        -:  860:  // to be used in ANY function of compatible type.
        -:  861:  template <typename F>
        -:  862:  operator Action<F>() const {
        -:  863:    return Action<F>(new Impl<F>(action1_, action2_));
        -:  864:  }
        -:  865:
        -:  866: private:
        -:  867:  // Implements the DoAll(...) action for a particular function type F.
        -:  868:  template <typename F>
        -:  869:  class Impl : public ActionInterface<F> {
        -:  870:   public:
        -:  871:    typedef typename Function<F>::Result Result;
        -:  872:    typedef typename Function<F>::ArgumentTuple ArgumentTuple;
        -:  873:    typedef typename Function<F>::MakeResultVoid VoidResult;
        -:  874:
        -:  875:    Impl(const Action<VoidResult>& action1, const Action<F>& action2)
        -:  876:        : action1_(action1), action2_(action2) {}
        -:  877:
        -:  878:    virtual Result Perform(const ArgumentTuple& args) {
        -:  879:      action1_.Perform(args);
        -:  880:      return action2_.Perform(args);
        -:  881:    }
        -:  882:
        -:  883:   private:
        -:  884:    const Action<VoidResult> action1_;
        -:  885:    const Action<F> action2_;
        -:  886:
        -:  887:    GTEST_DISALLOW_ASSIGN_(Impl);
        -:  888:  };
        -:  889:
        -:  890:  Action1 action1_;
        -:  891:  Action2 action2_;
        -:  892:
        -:  893:  GTEST_DISALLOW_ASSIGN_(DoBothAction);
        -:  894:};
        -:  895:
        -:  896:}  // namespace internal
        -:  897:
        -:  898:// An Unused object can be implicitly constructed from ANY value.
        -:  899:// This is handy when defining actions that ignore some or all of the
        -:  900:// mock function arguments.  For example, given
        -:  901://
        -:  902://   MOCK_METHOD3(Foo, double(const string& label, double x, double y));
        -:  903://   MOCK_METHOD3(Bar, double(int index, double x, double y));
        -:  904://
        -:  905:// instead of
        -:  906://
        -:  907://   double DistanceToOriginWithLabel(const string& label, double x, double y) {
        -:  908://     return sqrt(x*x + y*y);
        -:  909://   }
        -:  910://   double DistanceToOriginWithIndex(int index, double x, double y) {
        -:  911://     return sqrt(x*x + y*y);
        -:  912://   }
        -:  913://   ...
        -:  914://   EXEPCT_CALL(mock, Foo("abc", _, _))
        -:  915://       .WillOnce(Invoke(DistanceToOriginWithLabel));
        -:  916://   EXEPCT_CALL(mock, Bar(5, _, _))
        -:  917://       .WillOnce(Invoke(DistanceToOriginWithIndex));
        -:  918://
        -:  919:// you could write
        -:  920://
        -:  921://   // We can declare any uninteresting argument as Unused.
        -:  922://   double DistanceToOrigin(Unused, double x, double y) {
        -:  923://     return sqrt(x*x + y*y);
        -:  924://   }
        -:  925://   ...
        -:  926://   EXEPCT_CALL(mock, Foo("abc", _, _)).WillOnce(Invoke(DistanceToOrigin));
        -:  927://   EXEPCT_CALL(mock, Bar(5, _, _)).WillOnce(Invoke(DistanceToOrigin));
        -:  928:typedef internal::IgnoredValue Unused;
        -:  929:
        -:  930:// This constructor allows us to turn an Action<From> object into an
        -:  931:// Action<To>, as long as To's arguments can be implicitly converted
        -:  932:// to From's and From's return type cann be implicitly converted to
        -:  933:// To's.
        -:  934:template <typename To>
        -:  935:template <typename From>
        -:  936:Action<To>::Action(const Action<From>& from)
        -:  937:    : impl_(new internal::ActionAdaptor<To, From>(from)) {}
        -:  938:
        -:  939:// Creates an action that returns 'value'.  'value' is passed by value
        -:  940:// instead of const reference - otherwise Return("string literal")
        -:  941:// will trigger a compiler error about using array as initializer.
        -:  942:template <typename R>
       12:  943:internal::ReturnAction<R> Return(R value) {
       12:  944:  return internal::ReturnAction<R>(value);
        -:  945:}
        -:  946:
        -:  947:// Creates an action that returns NULL.
        -:  948:inline PolymorphicAction<internal::ReturnNullAction> ReturnNull() {
        -:  949:  return MakePolymorphicAction(internal::ReturnNullAction());
        -:  950:}
        -:  951:
        -:  952:// Creates an action that returns from a void function.
        -:  953:inline PolymorphicAction<internal::ReturnVoidAction> Return() {
        -:  954:  return MakePolymorphicAction(internal::ReturnVoidAction());
        -:  955:}
        -:  956:
        -:  957:// Creates an action that returns the reference to a variable.
        -:  958:template <typename R>
        -:  959:inline internal::ReturnRefAction<R> ReturnRef(R& x) {  // NOLINT
        -:  960:  return internal::ReturnRefAction<R>(x);
        -:  961:}
        -:  962:
        -:  963:// Creates an action that returns the reference to a copy of the
        -:  964:// argument.  The copy is created when the action is constructed and
        -:  965:// lives as long as the action.
        -:  966:template <typename R>
        -:  967:inline internal::ReturnRefOfCopyAction<R> ReturnRefOfCopy(const R& x) {
        -:  968:  return internal::ReturnRefOfCopyAction<R>(x);
        -:  969:}
        -:  970:
        -:  971:// Creates an action that does the default action for the give mock function.
       12:  972:inline internal::DoDefaultAction DoDefault() {
       12:  973:  return internal::DoDefaultAction();
        -:  974:}
        -:  975:
        -:  976:// Creates an action that sets the variable pointed by the N-th
        -:  977:// (0-based) function argument to 'value'.
        -:  978:template <size_t N, typename T>
        -:  979:PolymorphicAction<
        -:  980:  internal::SetArgumentPointeeAction<
        -:  981:    N, T, internal::IsAProtocolMessage<T>::value> >
        -:  982:SetArgPointee(const T& x) {
        -:  983:  return MakePolymorphicAction(internal::SetArgumentPointeeAction<
        -:  984:      N, T, internal::IsAProtocolMessage<T>::value>(x));
        -:  985:}
        -:  986:
        -:  987:#if !((GTEST_GCC_VER_ && GTEST_GCC_VER_ < 40000) || GTEST_OS_SYMBIAN)
        -:  988:// This overload allows SetArgPointee() to accept a string literal.
        -:  989:// GCC prior to the version 4.0 and Symbian C++ compiler cannot distinguish
        -:  990:// this overload from the templated version and emit a compile error.
        -:  991:template <size_t N>
        -:  992:PolymorphicAction<
        -:  993:  internal::SetArgumentPointeeAction<N, const char*, false> >
        -:  994:SetArgPointee(const char* p) {
        -:  995:  return MakePolymorphicAction(internal::SetArgumentPointeeAction<
        -:  996:      N, const char*, false>(p));
        -:  997:}
        -:  998:
        -:  999:template <size_t N>
        -: 1000:PolymorphicAction<
        -: 1001:  internal::SetArgumentPointeeAction<N, const wchar_t*, false> >
        -: 1002:SetArgPointee(const wchar_t* p) {
        -: 1003:  return MakePolymorphicAction(internal::SetArgumentPointeeAction<
        -: 1004:      N, const wchar_t*, false>(p));
        -: 1005:}
        -: 1006:#endif
        -: 1007:
        -: 1008:// The following version is DEPRECATED.
        -: 1009:template <size_t N, typename T>
        -: 1010:PolymorphicAction<
        -: 1011:  internal::SetArgumentPointeeAction<
        -: 1012:    N, T, internal::IsAProtocolMessage<T>::value> >
        -: 1013:SetArgumentPointee(const T& x) {
        -: 1014:  return MakePolymorphicAction(internal::SetArgumentPointeeAction<
        -: 1015:      N, T, internal::IsAProtocolMessage<T>::value>(x));
        -: 1016:}
        -: 1017:
        -: 1018:// Creates an action that sets a pointer referent to a given value.
        -: 1019:template <typename T1, typename T2>
        -: 1020:PolymorphicAction<internal::AssignAction<T1, T2> > Assign(T1* ptr, T2 val) {
        -: 1021:  return MakePolymorphicAction(internal::AssignAction<T1, T2>(ptr, val));
        -: 1022:}
        -: 1023:
        -: 1024:#if !GTEST_OS_WINDOWS_MOBILE
        -: 1025:
        -: 1026:// Creates an action that sets errno and returns the appropriate error.
        -: 1027:template <typename T>
        -: 1028:PolymorphicAction<internal::SetErrnoAndReturnAction<T> >
        -: 1029:SetErrnoAndReturn(int errval, T result) {
        -: 1030:  return MakePolymorphicAction(
        -: 1031:      internal::SetErrnoAndReturnAction<T>(errval, result));
        -: 1032:}
        -: 1033:
        -: 1034:#endif  // !GTEST_OS_WINDOWS_MOBILE
        -: 1035:
        -: 1036:// Various overloads for InvokeWithoutArgs().
        -: 1037:
        -: 1038:// Creates an action that invokes 'function_impl' with no argument.
        -: 1039:template <typename FunctionImpl>
        -: 1040:PolymorphicAction<internal::InvokeWithoutArgsAction<FunctionImpl> >
        -: 1041:InvokeWithoutArgs(FunctionImpl function_impl) {
        -: 1042:  return MakePolymorphicAction(
        -: 1043:      internal::InvokeWithoutArgsAction<FunctionImpl>(function_impl));
        -: 1044:}
        -: 1045:
        -: 1046:// Creates an action that invokes the given method on the given object
        -: 1047:// with no argument.
        -: 1048:template <class Class, typename MethodPtr>
        -: 1049:PolymorphicAction<internal::InvokeMethodWithoutArgsAction<Class, MethodPtr> >
        -: 1050:InvokeWithoutArgs(Class* obj_ptr, MethodPtr method_ptr) {
        -: 1051:  return MakePolymorphicAction(
        -: 1052:      internal::InvokeMethodWithoutArgsAction<Class, MethodPtr>(
        -: 1053:          obj_ptr, method_ptr));
        -: 1054:}
        -: 1055:
        -: 1056:// Creates an action that performs an_action and throws away its
        -: 1057:// result.  In other words, it changes the return type of an_action to
        -: 1058:// void.  an_action MUST NOT return void, or the code won't compile.
        -: 1059:template <typename A>
        -: 1060:inline internal::IgnoreResultAction<A> IgnoreResult(const A& an_action) {
        -: 1061:  return internal::IgnoreResultAction<A>(an_action);
        -: 1062:}
        -: 1063:
        -: 1064:// Creates a reference wrapper for the given L-value.  If necessary,
        -: 1065:// you can explicitly specify the type of the reference.  For example,
        -: 1066:// suppose 'derived' is an object of type Derived, ByRef(derived)
        -: 1067:// would wrap a Derived&.  If you want to wrap a const Base& instead,
        -: 1068:// where Base is a base class of Derived, just write:
        -: 1069://
        -: 1070://   ByRef<const Base>(derived)
        -: 1071:template <typename T>
        -: 1072:inline internal::ReferenceWrapper<T> ByRef(T& l_value) {  // NOLINT
        -: 1073:  return internal::ReferenceWrapper<T>(l_value);
        -: 1074:}
        -: 1075:
        -: 1076:}  // namespace testing
        -: 1077:
        -: 1078:#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
