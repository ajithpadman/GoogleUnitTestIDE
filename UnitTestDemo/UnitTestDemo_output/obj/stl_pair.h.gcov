        -:    0:Source:c:/mingw/lib/gcc/mingw32/4.7.1/include/c++/bits/stl_pair.h
        -:    0:Graph:UnitDemo_function4_b_test.gcno
        -:    0:Data:UnitDemo_function4_b_test.gcda
        -:    0:Runs:15
        -:    0:Programs:1
        -:    1:// Pair implementation -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
        -:    4:// 2010, 2011
        -:    5:// Free Software Foundation, Inc.
        -:    6://
        -:    7:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    8:// software; you can redistribute it and/or modify it under the
        -:    9:// terms of the GNU General Public License as published by the
        -:   10:// Free Software Foundation; either version 3, or (at your option)
        -:   11:// any later version.
        -:   12:
        -:   13:// This library is distributed in the hope that it will be useful,
        -:   14:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:// GNU General Public License for more details.
        -:   17:
        -:   18:// Under Section 7 of GPL version 3, you are granted additional
        -:   19:// permissions described in the GCC Runtime Library Exception, version
        -:   20:// 3.1, as published by the Free Software Foundation.
        -:   21:
        -:   22:// You should have received a copy of the GNU General Public License and
        -:   23:// a copy of the GCC Runtime Library Exception along with this program;
        -:   24:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   25:// <http://www.gnu.org/licenses/>.
        -:   26:
        -:   27:/*
        -:   28: *
        -:   29: * Copyright (c) 1994
        -:   30: * Hewlett-Packard Company
        -:   31: *
        -:   32: * Permission to use, copy, modify, distribute and sell this software
        -:   33: * and its documentation for any purpose is hereby granted without fee,
        -:   34: * provided that the above copyright notice appear in all copies and
        -:   35: * that both that copyright notice and this permission notice appear
        -:   36: * in supporting documentation.  Hewlett-Packard Company makes no
        -:   37: * representations about the suitability of this software for any
        -:   38: * purpose.  It is provided "as is" without express or implied warranty.
        -:   39: *
        -:   40: *
        -:   41: * Copyright (c) 1996,1997
        -:   42: * Silicon Graphics Computer Systems, Inc.
        -:   43: *
        -:   44: * Permission to use, copy, modify, distribute and sell this software
        -:   45: * and its documentation for any purpose is hereby granted without fee,
        -:   46: * provided that the above copyright notice appear in all copies and
        -:   47: * that both that copyright notice and this permission notice appear
        -:   48: * in supporting documentation.  Silicon Graphics makes no
        -:   49: * representations about the suitability of this software for any
        -:   50: * purpose.  It is provided "as is" without express or implied warranty.
        -:   51: */
        -:   52:
        -:   53:/** @file bits/stl_pair.h
        -:   54: *  This is an internal header file, included by other library headers.
        -:   55: *  Do not attempt to use it directly. @headername{utility}
        -:   56: */
        -:   57:
        -:   58:#ifndef _STL_PAIR_H
        -:   59:#define _STL_PAIR_H 1
        -:   60:
        -:   61:#include <bits/move.h> // for std::move / std::forward, and std::swap
        -:   62:
        -:   63:#ifdef __GXX_EXPERIMENTAL_CXX0X__
        -:   64:#include <type_traits> // for std::__decay_and_strip too
        -:   65:#endif
        -:   66:
        -:   67:namespace std _GLIBCXX_VISIBILITY(default)
        -:   68:{
        -:   69:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   70:
        -:   71:#ifdef __GXX_EXPERIMENTAL_CXX0X__
        -:   72:  /// piecewise_construct_t
        -:   73:  struct piecewise_construct_t { };
        -:   74:
        -:   75:  /// piecewise_construct
        -:   76:  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
        -:   77:
        -:   78:  // Forward declarations.
        -:   79:  template<typename...>
        -:   80:    class tuple;
        -:   81:
        -:   82:  template<std::size_t...>
        -:   83:    struct _Index_tuple;
        -:   84:#endif
        -:   85:
        -:   86:  /// Struct holding two objects of arbitrary type.
        -:   87:  template<class _T1, class _T2>
       45:   88:    struct pair
        -:   89:    {
        -:   90:      typedef _T1 first_type;    /// @c first_type is the first bound type
        -:   91:      typedef _T2 second_type;   /// @c second_type is the second bound type
        -:   92:
        -:   93:      _T1 first;                 /// @c first is a copy of the first object
        -:   94:      _T2 second;                /// @c second is a copy of the second object
        -:   95:
        -:   96:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:   97:      // 265.  std::pair::pair() effects overly restrictive
        -:   98:      /** The default constructor creates @c first and @c second using their
        -:   99:       *  respective default constructors.  */
        -:  100:      _GLIBCXX_CONSTEXPR pair()
        -:  101:      : first(), second() { }
        -:  102:
        -:  103:      /** Two objects may be passed to a @c pair constructor to be copied.  */
       15:  104:      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
       15:  105:      : first(__a), second(__b) { }
        -:  106:
        -:  107:      /** There is also a templated copy ctor for the @c pair class itself.  */
        -:  108:#ifndef __GXX_EXPERIMENTAL_CXX0X__
        -:  109:      template<class _U1, class _U2>
        -:  110:	pair(const pair<_U1, _U2>& __p)
        -:  111:	: first(__p.first), second(__p.second) { }
        -:  112:#else
        -:  113:      template<class _U1, class _U2, class = typename
        -:  114:	       enable_if<__and_<is_convertible<const _U1&, _T1>,
        -:  115:				is_convertible<const _U2&, _T2>>::value>::type>
        -:  116:	constexpr pair(const pair<_U1, _U2>& __p)
        -:  117:	: first(__p.first), second(__p.second) { }
        -:  118:
        -:  119:      constexpr pair(const pair&) = default;
        -:  120:
        -:  121:      // XXX Defaulted?!? Breaks std::map!!!
        -:  122:      pair(pair&& __p)
        -:  123:      noexcept(__and_<is_nothrow_move_constructible<_T1>,
        -:  124:	              is_nothrow_move_constructible<_T2>>::value)
        -:  125:      : first(std::forward<first_type>(__p.first)),
        -:  126:	second(std::forward<second_type>(__p.second)) { }
        -:  127:
        -:  128:      // DR 811.
        -:  129:      template<class _U1, class = typename
        -:  130:	       enable_if<is_convertible<_U1, _T1>::value>::type>
        -:  131:	constexpr pair(_U1&& __x, const _T2& __y)
        -:  132:	: first(std::forward<_U1>(__x)), second(__y) { }
        -:  133:
        -:  134:      template<class _U2, class = typename
        -:  135:	       enable_if<is_convertible<_U2, _T2>::value>::type>
        -:  136:	constexpr pair(const _T1& __x, _U2&& __y)
        -:  137:	: first(__x), second(std::forward<_U2>(__y)) { }
        -:  138:
        -:  139:      template<class _U1, class _U2, class = typename
        -:  140:	       enable_if<__and_<is_convertible<_U1, _T1>,
        -:  141:				is_convertible<_U2, _T2>>::value>::type>
        -:  142:	constexpr pair(_U1&& __x, _U2&& __y)
        -:  143:	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
        -:  144:
        -:  145:      template<class _U1, class _U2, class = typename
        -:  146:	       enable_if<__and_<is_convertible<_U1, _T1>,
        -:  147:				is_convertible<_U2, _T2>>::value>::type>
        -:  148:	constexpr pair(pair<_U1, _U2>&& __p)
        -:  149:	: first(std::forward<_U1>(__p.first)),
        -:  150:	  second(std::forward<_U2>(__p.second)) { }
        -:  151:
        -:  152:      template<typename... _Args1, typename... _Args2>
        -:  153:        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        -:  154:
        -:  155:      pair&
        -:  156:      operator=(const pair& __p)
        -:  157:      {
        -:  158:	first = __p.first;
        -:  159:	second = __p.second;
        -:  160:	return *this;
        -:  161:      }
        -:  162:
        -:  163:      pair&
        -:  164:      operator=(pair&& __p)
        -:  165:      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        -:  166:	              is_nothrow_move_assignable<_T2>>::value)
        -:  167:      {
        -:  168:	first = std::forward<first_type>(__p.first);
        -:  169:	second = std::forward<second_type>(__p.second);
        -:  170:	return *this;
        -:  171:      }
        -:  172:
        -:  173:      template<class _U1, class _U2>
        -:  174:	pair&
        -:  175:	operator=(const pair<_U1, _U2>& __p)
        -:  176:	{
        -:  177:	  first = __p.first;
        -:  178:	  second = __p.second;
        -:  179:	  return *this;
        -:  180:	}
        -:  181:
        -:  182:      template<class _U1, class _U2>
        -:  183:	pair&
        -:  184:	operator=(pair<_U1, _U2>&& __p)
        -:  185:	{
        -:  186:	  first = std::forward<_U1>(__p.first);
        -:  187:	  second = std::forward<_U2>(__p.second);
        -:  188:	  return *this;
        -:  189:	}
        -:  190:
        -:  191:      void
        -:  192:      swap(pair& __p)
        -:  193:      noexcept(noexcept(swap(first, __p.first))
        -:  194:	       && noexcept(swap(second, __p.second)))
        -:  195:      {
        -:  196:	using std::swap;
        -:  197:	swap(first, __p.first);
        -:  198:	swap(second, __p.second);
        -:  199:      }
        -:  200:
        -:  201:    private:
        -:  202:      template<typename... _Args1, std::size_t... _Indexes1,
        -:  203:               typename... _Args2, std::size_t... _Indexes2>
        -:  204:        pair(tuple<_Args1...>&, tuple<_Args2...>&,
        -:  205:             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
        -:  206:#endif
        -:  207:    };
        -:  208:
        -:  209:  /// Two pairs of the same type are equal iff their members are equal.
        -:  210:  template<class _T1, class _T2>
        -:  211:    inline _GLIBCXX_CONSTEXPR bool
        -:  212:    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
        -:  213:    { return __x.first == __y.first && __x.second == __y.second; }
        -:  214:
        -:  215:  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
        -:  216:  template<class _T1, class _T2>
        -:  217:    inline _GLIBCXX_CONSTEXPR bool
        -:  218:    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
        -:  219:    { return __x.first < __y.first
        -:  220:	     || (!(__y.first < __x.first) && __x.second < __y.second); }
        -:  221:
        -:  222:  /// Uses @c operator== to find the result.
        -:  223:  template<class _T1, class _T2>
        -:  224:    inline _GLIBCXX_CONSTEXPR bool
        -:  225:    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
        -:  226:    { return !(__x == __y); }
        -:  227:
        -:  228:  /// Uses @c operator< to find the result.
        -:  229:  template<class _T1, class _T2>
        -:  230:    inline _GLIBCXX_CONSTEXPR bool
        -:  231:    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
        -:  232:    { return __y < __x; }
        -:  233:
        -:  234:  /// Uses @c operator< to find the result.
        -:  235:  template<class _T1, class _T2>
        -:  236:    inline _GLIBCXX_CONSTEXPR bool
        -:  237:    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
        -:  238:    { return !(__y < __x); }
        -:  239:
        -:  240:  /// Uses @c operator< to find the result.
        -:  241:  template<class _T1, class _T2>
        -:  242:    inline _GLIBCXX_CONSTEXPR bool
        -:  243:    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
        -:  244:    { return !(__x < __y); }
        -:  245:
        -:  246:#ifdef __GXX_EXPERIMENTAL_CXX0X__
        -:  247:  /// See std::pair::swap().
        -:  248:  // Note:  no std::swap overloads in C++03 mode, this has performance
        -:  249:  //        implications, see, eg, libstdc++/38466.
        -:  250:  template<class _T1, class _T2>
        -:  251:    inline void
        -:  252:    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
        -:  253:    noexcept(noexcept(__x.swap(__y)))
        -:  254:    { __x.swap(__y); }
        -:  255:#endif
        -:  256:
        -:  257:  /**
        -:  258:   *  @brief A convenience wrapper for creating a pair from two objects.
        -:  259:   *  @param  __x  The first object.
        -:  260:   *  @param  __y  The second object.
        -:  261:   *  @return   A newly-constructed pair<> object of the appropriate type.
        -:  262:   *
        -:  263:   *  The standard requires that the objects be passed by reference-to-const,
        -:  264:   *  but LWG issue #181 says they should be passed by const value.  We follow
        -:  265:   *  the LWG by default.
        -:  266:   */
        -:  267:  // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  268:  // 181.  make_pair() unintended behavior
        -:  269:#ifdef __GXX_EXPERIMENTAL_CXX0X__
        -:  270:  // NB: DR 706.
        -:  271:  template<class _T1, class _T2>
        -:  272:    constexpr pair<typename __decay_and_strip<_T1>::__type,
        -:  273:                   typename __decay_and_strip<_T2>::__type>
        -:  274:    make_pair(_T1&& __x, _T2&& __y)
        -:  275:    {
        -:  276:      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
        -:  277:      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
        -:  278:      typedef pair<__ds_type1, __ds_type2> 	      __pair_type;
        -:  279:      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
        -:  280:    }
        -:  281:#else
        -:  282:  template<class _T1, class _T2>
        -:  283:    inline pair<_T1, _T2>
       15:  284:    make_pair(_T1 __x, _T2 __y)
       15:  285:    { return pair<_T1, _T2>(__x, __y); }
        -:  286:#endif
        -:  287:
        -:  288:_GLIBCXX_END_NAMESPACE_VERSION
        -:  289:} // namespace
        -:  290:
        -:  291:#endif /* _STL_PAIR_H */
