        -:    0:Source:D:/UnitTestDemo/GtestIncludes/gmock/internal/gmock-internal-utils.h
        -:    0:Graph:UnitDemo_function4_b_test.gcno
        -:    0:Data:UnitDemo_function4_b_test.gcda
        -:    0:Runs:15
        -:    0:Programs:1
        -:    1:// Copyright 2007, Google Inc.
        -:    2:// All rights reserved.
        -:    3://
        -:    4:// Redistribution and use in source and binary forms, with or without
        -:    5:// modification, are permitted provided that the following conditions are
        -:    6:// met:
        -:    7://
        -:    8://     * Redistributions of source code must retain the above copyright
        -:    9:// notice, this list of conditions and the following disclaimer.
        -:   10://     * Redistributions in binary form must reproduce the above
        -:   11:// copyright notice, this list of conditions and the following disclaimer
        -:   12:// in the documentation and/or other materials provided with the
        -:   13:// distribution.
        -:   14://     * Neither the name of Google Inc. nor the names of its
        -:   15:// contributors may be used to endorse or promote products derived from
        -:   16:// this software without specific prior written permission.
        -:   17://
        -:   18:// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   19:// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   20:// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   21:// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   22:// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   23:// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   24:// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   25:// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   26:// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   27:// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   28:// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   29://
        -:   30:// Author: wan@google.com (Zhanyong Wan)
        -:   31:
        -:   32:// Google Mock - a framework for writing C++ mock classes.
        -:   33://
        -:   34:// This file defines some utilities useful for implementing Google
        -:   35:// Mock.  They are subject to change without notice, so please DO NOT
        -:   36:// USE THEM IN USER CODE.
        -:   37:
        -:   38:#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_
        -:   39:#define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_
        -:   40:
        -:   41:#include <stdio.h>
        -:   42:#include <ostream>  // NOLINT
        -:   43:#include <string>
        -:   44:
        -:   45:#include "gmock/internal/gmock-generated-internal-utils.h"
        -:   46:#include "gmock/internal/gmock-port.h"
        -:   47:#include "gtest/gtest.h"
        -:   48:
        -:   49:namespace testing {
        -:   50:namespace internal {
        -:   51:
        -:   52:// Converts an identifier name to a space-separated list of lower-case
        -:   53:// words.  Each maximum substring of the form [A-Za-z][a-z]*|\d+ is
        -:   54:// treated as one word.  For example, both "FooBar123" and
        -:   55:// "foo_bar_123" are converted to "foo bar 123".
        -:   56:GTEST_API_ string ConvertIdentifierNameToWords(const char* id_name);
        -:   57:
        -:   58:// PointeeOf<Pointer>::type is the type of a value pointed to by a
        -:   59:// Pointer, which can be either a smart pointer or a raw pointer.  The
        -:   60:// following default implementation is for the case where Pointer is a
        -:   61:// smart pointer.
        -:   62:template <typename Pointer>
        -:   63:struct PointeeOf {
        -:   64:  // Smart pointer classes define type element_type as the type of
        -:   65:  // their pointees.
        -:   66:  typedef typename Pointer::element_type type;
        -:   67:};
        -:   68:// This specialization is for the raw pointer case.
        -:   69:template <typename T>
        -:   70:struct PointeeOf<T*> { typedef T type; };  // NOLINT
        -:   71:
        -:   72:// GetRawPointer(p) returns the raw pointer underlying p when p is a
        -:   73:// smart pointer, or returns p itself when p is already a raw pointer.
        -:   74:// The following default implementation is for the smart pointer case.
        -:   75:template <typename Pointer>
        -:   76:inline const typename Pointer::element_type* GetRawPointer(const Pointer& p) {
        -:   77:  return p.get();
        -:   78:}
        -:   79:// This overloaded version is for the raw pointer case.
        -:   80:template <typename Element>
        -:   81:inline Element* GetRawPointer(Element* p) { return p; }
        -:   82:
        -:   83:// This comparator allows linked_ptr to be stored in sets.
        -:   84:template <typename T>
        -:   85:struct LinkedPtrLessThan {
        -:   86:  bool operator()(const ::testing::internal::linked_ptr<T>& lhs,
        -:   87:                  const ::testing::internal::linked_ptr<T>& rhs) const {
        -:   88:    return lhs.get() < rhs.get();
        -:   89:  }
        -:   90:};
        -:   91:
        -:   92:// Symbian compilation can be done with wchar_t being either a native
        -:   93:// type or a typedef.  Using Google Mock with OpenC without wchar_t
        -:   94:// should require the definition of _STLP_NO_WCHAR_T.
        -:   95://
        -:   96:// MSVC treats wchar_t as a native type usually, but treats it as the
        -:   97:// same as unsigned short when the compiler option /Zc:wchar_t- is
        -:   98:// specified.  It defines _NATIVE_WCHAR_T_DEFINED symbol when wchar_t
        -:   99:// is a native type.
        -:  100:#if (GTEST_OS_SYMBIAN && defined(_STLP_NO_WCHAR_T)) || \
        -:  101:    (defined(_MSC_VER) && !defined(_NATIVE_WCHAR_T_DEFINED))
        -:  102:// wchar_t is a typedef.
        -:  103:#else
        -:  104:# define GMOCK_WCHAR_T_IS_NATIVE_ 1
        -:  105:#endif
        -:  106:
        -:  107:// signed wchar_t and unsigned wchar_t are NOT in the C++ standard.
        -:  108:// Using them is a bad practice and not portable.  So DON'T use them.
        -:  109://
        -:  110:// Still, Google Mock is designed to work even if the user uses signed
        -:  111:// wchar_t or unsigned wchar_t (obviously, assuming the compiler
        -:  112:// supports them).
        -:  113://
        -:  114:// To gcc,
        -:  115://   wchar_t == signed wchar_t != unsigned wchar_t == unsigned int
        -:  116:#ifdef __GNUC__
        -:  117:// signed/unsigned wchar_t are valid types.
        -:  118:# define GMOCK_HAS_SIGNED_WCHAR_T_ 1
        -:  119:#endif
        -:  120:
        -:  121:// In what follows, we use the term "kind" to indicate whether a type
        -:  122:// is bool, an integer type (excluding bool), a floating-point type,
        -:  123:// or none of them.  This categorization is useful for determining
        -:  124:// when a matcher argument type can be safely converted to another
        -:  125:// type in the implementation of SafeMatcherCast.
        -:  126:enum TypeKind {
        -:  127:  kBool, kInteger, kFloatingPoint, kOther
        -:  128:};
        -:  129:
        -:  130:// KindOf<T>::value is the kind of type T.
        -:  131:template <typename T> struct KindOf {
        -:  132:  enum { value = kOther };  // The default kind.
        -:  133:};
        -:  134:
        -:  135:// This macro declares that the kind of 'type' is 'kind'.
        -:  136:#define GMOCK_DECLARE_KIND_(type, kind) \
        -:  137:  template <> struct KindOf<type> { enum { value = kind }; }
        -:  138:
        -:  139:GMOCK_DECLARE_KIND_(bool, kBool);
        -:  140:
        -:  141:// All standard integer types.
        -:  142:GMOCK_DECLARE_KIND_(char, kInteger);
        -:  143:GMOCK_DECLARE_KIND_(signed char, kInteger);
        -:  144:GMOCK_DECLARE_KIND_(unsigned char, kInteger);
        -:  145:GMOCK_DECLARE_KIND_(short, kInteger);  // NOLINT
        -:  146:GMOCK_DECLARE_KIND_(unsigned short, kInteger);  // NOLINT
        -:  147:GMOCK_DECLARE_KIND_(int, kInteger);
        -:  148:GMOCK_DECLARE_KIND_(unsigned int, kInteger);
        -:  149:GMOCK_DECLARE_KIND_(long, kInteger);  // NOLINT
        -:  150:GMOCK_DECLARE_KIND_(unsigned long, kInteger);  // NOLINT
        -:  151:
        -:  152:#if GMOCK_WCHAR_T_IS_NATIVE_
        -:  153:GMOCK_DECLARE_KIND_(wchar_t, kInteger);
        -:  154:#endif
        -:  155:
        -:  156:// Non-standard integer types.
        -:  157:GMOCK_DECLARE_KIND_(Int64, kInteger);
        -:  158:GMOCK_DECLARE_KIND_(UInt64, kInteger);
        -:  159:
        -:  160:// All standard floating-point types.
        -:  161:GMOCK_DECLARE_KIND_(float, kFloatingPoint);
        -:  162:GMOCK_DECLARE_KIND_(double, kFloatingPoint);
        -:  163:GMOCK_DECLARE_KIND_(long double, kFloatingPoint);
        -:  164:
        -:  165:#undef GMOCK_DECLARE_KIND_
        -:  166:
        -:  167:// Evaluates to the kind of 'type'.
        -:  168:#define GMOCK_KIND_OF_(type) \
        -:  169:  static_cast< ::testing::internal::TypeKind>( \
        -:  170:      ::testing::internal::KindOf<type>::value)
        -:  171:
        -:  172:// Evaluates to true iff integer type T is signed.
        -:  173:#define GMOCK_IS_SIGNED_(T) (static_cast<T>(-1) < 0)
        -:  174:
        -:  175:// LosslessArithmeticConvertibleImpl<kFromKind, From, kToKind, To>::value
        -:  176:// is true iff arithmetic type From can be losslessly converted to
        -:  177:// arithmetic type To.
        -:  178://
        -:  179:// It's the user's responsibility to ensure that both From and To are
        -:  180:// raw (i.e. has no CV modifier, is not a pointer, and is not a
        -:  181:// reference) built-in arithmetic types, kFromKind is the kind of
        -:  182:// From, and kToKind is the kind of To; the value is
        -:  183:// implementation-defined when the above pre-condition is violated.
        -:  184:template <TypeKind kFromKind, typename From, TypeKind kToKind, typename To>
        -:  185:struct LosslessArithmeticConvertibleImpl : public false_type {};
        -:  186:
        -:  187:// Converting bool to bool is lossless.
        -:  188:template <>
        -:  189:struct LosslessArithmeticConvertibleImpl<kBool, bool, kBool, bool>
        -:  190:    : public true_type {};  // NOLINT
        -:  191:
        -:  192:// Converting bool to any integer type is lossless.
        -:  193:template <typename To>
        -:  194:struct LosslessArithmeticConvertibleImpl<kBool, bool, kInteger, To>
        -:  195:    : public true_type {};  // NOLINT
        -:  196:
        -:  197:// Converting bool to any floating-point type is lossless.
        -:  198:template <typename To>
        -:  199:struct LosslessArithmeticConvertibleImpl<kBool, bool, kFloatingPoint, To>
        -:  200:    : public true_type {};  // NOLINT
        -:  201:
        -:  202:// Converting an integer to bool is lossy.
        -:  203:template <typename From>
        -:  204:struct LosslessArithmeticConvertibleImpl<kInteger, From, kBool, bool>
        -:  205:    : public false_type {};  // NOLINT
        -:  206:
        -:  207:// Converting an integer to another non-bool integer is lossless iff
        -:  208:// the target type's range encloses the source type's range.
        -:  209:template <typename From, typename To>
        -:  210:struct LosslessArithmeticConvertibleImpl<kInteger, From, kInteger, To>
        -:  211:    : public bool_constant<
        -:  212:      // When converting from a smaller size to a larger size, we are
        -:  213:      // fine as long as we are not converting from signed to unsigned.
        -:  214:      ((sizeof(From) < sizeof(To)) &&
        -:  215:       (!GMOCK_IS_SIGNED_(From) || GMOCK_IS_SIGNED_(To))) ||
        -:  216:      // When converting between the same size, the signedness must match.
        -:  217:      ((sizeof(From) == sizeof(To)) &&
        -:  218:       (GMOCK_IS_SIGNED_(From) == GMOCK_IS_SIGNED_(To)))> {};  // NOLINT
        -:  219:
        -:  220:#undef GMOCK_IS_SIGNED_
        -:  221:
        -:  222:// Converting an integer to a floating-point type may be lossy, since
        -:  223:// the format of a floating-point number is implementation-defined.
        -:  224:template <typename From, typename To>
        -:  225:struct LosslessArithmeticConvertibleImpl<kInteger, From, kFloatingPoint, To>
        -:  226:    : public false_type {};  // NOLINT
        -:  227:
        -:  228:// Converting a floating-point to bool is lossy.
        -:  229:template <typename From>
        -:  230:struct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kBool, bool>
        -:  231:    : public false_type {};  // NOLINT
        -:  232:
        -:  233:// Converting a floating-point to an integer is lossy.
        -:  234:template <typename From, typename To>
        -:  235:struct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kInteger, To>
        -:  236:    : public false_type {};  // NOLINT
        -:  237:
        -:  238:// Converting a floating-point to another floating-point is lossless
        -:  239:// iff the target type is at least as big as the source type.
        -:  240:template <typename From, typename To>
        -:  241:struct LosslessArithmeticConvertibleImpl<
        -:  242:  kFloatingPoint, From, kFloatingPoint, To>
        -:  243:    : public bool_constant<sizeof(From) <= sizeof(To)> {};  // NOLINT
        -:  244:
        -:  245:// LosslessArithmeticConvertible<From, To>::value is true iff arithmetic
        -:  246:// type From can be losslessly converted to arithmetic type To.
        -:  247://
        -:  248:// It's the user's responsibility to ensure that both From and To are
        -:  249:// raw (i.e. has no CV modifier, is not a pointer, and is not a
        -:  250:// reference) built-in arithmetic types; the value is
        -:  251:// implementation-defined when the above pre-condition is violated.
        -:  252:template <typename From, typename To>
        -:  253:struct LosslessArithmeticConvertible
        -:  254:    : public LosslessArithmeticConvertibleImpl<
        -:  255:  GMOCK_KIND_OF_(From), From, GMOCK_KIND_OF_(To), To> {};  // NOLINT
        -:  256:
        -:  257:// This interface knows how to report a Google Mock failure (either
        -:  258:// non-fatal or fatal).
        -:  259:class FailureReporterInterface {
        -:  260: public:
        -:  261:  // The type of a failure (either non-fatal or fatal).
        -:  262:  enum FailureType {
        -:  263:    kNonfatal, kFatal
        -:  264:  };
        -:  265:
    #####:  266:  virtual ~FailureReporterInterface() {}
        -:  267:
        -:  268:  // Reports a failure that occurred at the given source file location.
        -:  269:  virtual void ReportFailure(FailureType type, const char* file, int line,
        -:  270:                             const string& message) = 0;
        -:  271:};
        -:  272:
        -:  273:// Returns the failure reporter used by Google Mock.
        -:  274:GTEST_API_ FailureReporterInterface* GetFailureReporter();
        -:  275:
        -:  276:// Asserts that condition is true; aborts the process with the given
        -:  277:// message if condition is false.  We cannot use LOG(FATAL) or CHECK()
        -:  278:// as Google Mock might be used to mock the log sink itself.  We
        -:  279:// inline this function to prevent it from showing up in the stack
        -:  280:// trace.
        -:  281:inline void Assert(bool condition, const char* file, int line,
        -:  282:                   const string& msg) {
        -:  283:  if (!condition) {
        -:  284:    GetFailureReporter()->ReportFailure(FailureReporterInterface::kFatal,
        -:  285:                                        file, line, msg);
        -:  286:  }
        -:  287:}
        -:  288:inline void Assert(bool condition, const char* file, int line) {
        -:  289:  Assert(condition, file, line, "Assertion failed.");
        -:  290:}
        -:  291:
        -:  292:// Verifies that condition is true; generates a non-fatal failure if
        -:  293:// condition is false.
        -:  294:inline void Expect(bool condition, const char* file, int line,
        -:  295:                   const string& msg) {
        -:  296:  if (!condition) {
        -:  297:    GetFailureReporter()->ReportFailure(FailureReporterInterface::kNonfatal,
        -:  298:                                        file, line, msg);
        -:  299:  }
        -:  300:}
        -:  301:inline void Expect(bool condition, const char* file, int line) {
        -:  302:  Expect(condition, file, line, "Expectation failed.");
        -:  303:}
        -:  304:
        -:  305:// Severity level of a log.
        -:  306:enum LogSeverity {
        -:  307:  kInfo = 0,
        -:  308:  kWarning = 1
        -:  309:};
        -:  310:
        -:  311:// Valid values for the --gmock_verbose flag.
        -:  312:
        -:  313:// All logs (informational and warnings) are printed.
        -:  314:const char kInfoVerbosity[] = "info";
        -:  315:// Only warnings are printed.
        -:  316:const char kWarningVerbosity[] = "warning";
        -:  317:// No logs are printed.
        -:  318:const char kErrorVerbosity[] = "error";
        -:  319:
        -:  320:// Returns true iff a log with the given severity is visible according
        -:  321:// to the --gmock_verbose flag.
        -:  322:GTEST_API_ bool LogIsVisible(LogSeverity severity);
        -:  323:
        -:  324:// Prints the given message to stdout iff 'severity' >= the level
        -:  325:// specified by the --gmock_verbose flag.  If stack_frames_to_skip >=
        -:  326:// 0, also prints the stack trace excluding the top
        -:  327:// stack_frames_to_skip frames.  In opt mode, any positive
        -:  328:// stack_frames_to_skip is treated as 0, since we don't know which
        -:  329:// function calls will be inlined by the compiler and need to be
        -:  330:// conservative.
        -:  331:GTEST_API_ void Log(LogSeverity severity,
        -:  332:                    const string& message,
        -:  333:                    int stack_frames_to_skip);
        -:  334:
        -:  335:// TODO(wan@google.com): group all type utilities together.
        -:  336:
        -:  337:// Type traits.
        -:  338:
        -:  339:// is_reference<T>::value is non-zero iff T is a reference type.
        -:  340:template <typename T> struct is_reference : public false_type {};
        -:  341:template <typename T> struct is_reference<T&> : public true_type {};
        -:  342:
        -:  343:// type_equals<T1, T2>::value is non-zero iff T1 and T2 are the same type.
        -:  344:template <typename T1, typename T2> struct type_equals : public false_type {};
        -:  345:template <typename T> struct type_equals<T, T> : public true_type {};
        -:  346:
        -:  347:// remove_reference<T>::type removes the reference from type T, if any.
        -:  348:template <typename T> struct remove_reference { typedef T type; };  // NOLINT
        -:  349:template <typename T> struct remove_reference<T&> { typedef T type; }; // NOLINT
        -:  350:
        -:  351:// DecayArray<T>::type turns an array type U[N] to const U* and preserves
        -:  352:// other types.  Useful for saving a copy of a function argument.
        -:  353:template <typename T> struct DecayArray { typedef T type; };  // NOLINT
        -:  354:template <typename T, size_t N> struct DecayArray<T[N]> {
        -:  355:  typedef const T* type;
        -:  356:};
        -:  357:// Sometimes people use arrays whose size is not available at the use site
        -:  358:// (e.g. extern const char kNamePrefix[]).  This specialization covers that
        -:  359:// case.
        -:  360:template <typename T> struct DecayArray<T[]> {
        -:  361:  typedef const T* type;
        -:  362:};
        -:  363:
        -:  364:// Invalid<T>() returns an invalid value of type T.  This is useful
        -:  365:// when a value of type T is needed for compilation, but the statement
        -:  366:// will not really be executed (or we don't care if the statement
        -:  367:// crashes).
        -:  368:template <typename T>
        -:  369:inline T Invalid() {
        -:  370:  return const_cast<typename remove_reference<T>::type&>(
        -:  371:      *static_cast<volatile typename remove_reference<T>::type*>(NULL));
        -:  372:}
        -:  373:template <>
        -:  374:inline void Invalid<void>() {}
        -:  375:
        -:  376:// Given a raw type (i.e. having no top-level reference or const
        -:  377:// modifier) RawContainer that's either an STL-style container or a
        -:  378:// native array, class StlContainerView<RawContainer> has the
        -:  379:// following members:
        -:  380://
        -:  381://   - type is a type that provides an STL-style container view to
        -:  382://     (i.e. implements the STL container concept for) RawContainer;
        -:  383://   - const_reference is a type that provides a reference to a const
        -:  384://     RawContainer;
        -:  385://   - ConstReference(raw_container) returns a const reference to an STL-style
        -:  386://     container view to raw_container, which is a RawContainer.
        -:  387://   - Copy(raw_container) returns an STL-style container view of a
        -:  388://     copy of raw_container, which is a RawContainer.
        -:  389://
        -:  390:// This generic version is used when RawContainer itself is already an
        -:  391:// STL-style container.
        -:  392:template <class RawContainer>
        -:  393:class StlContainerView {
        -:  394: public:
        -:  395:  typedef RawContainer type;
        -:  396:  typedef const type& const_reference;
        -:  397:
        -:  398:  static const_reference ConstReference(const RawContainer& container) {
        -:  399:    // Ensures that RawContainer is not a const type.
        -:  400:    testing::StaticAssertTypeEq<RawContainer,
        -:  401:        GTEST_REMOVE_CONST_(RawContainer)>();
        -:  402:    return container;
        -:  403:  }
        -:  404:  static type Copy(const RawContainer& container) { return container; }
        -:  405:};
        -:  406:
        -:  407:// This specialization is used when RawContainer is a native array type.
        -:  408:template <typename Element, size_t N>
        -:  409:class StlContainerView<Element[N]> {
        -:  410: public:
        -:  411:  typedef GTEST_REMOVE_CONST_(Element) RawElement;
        -:  412:  typedef internal::NativeArray<RawElement> type;
        -:  413:  // NativeArray<T> can represent a native array either by value or by
        -:  414:  // reference (selected by a constructor argument), so 'const type'
        -:  415:  // can be used to reference a const native array.  We cannot
        -:  416:  // 'typedef const type& const_reference' here, as that would mean
        -:  417:  // ConstReference() has to return a reference to a local variable.
        -:  418:  typedef const type const_reference;
        -:  419:
        -:  420:  static const_reference ConstReference(const Element (&array)[N]) {
        -:  421:    // Ensures that Element is not a const type.
        -:  422:    testing::StaticAssertTypeEq<Element, RawElement>();
        -:  423:#if GTEST_OS_SYMBIAN
        -:  424:    // The Nokia Symbian compiler confuses itself in template instantiation
        -:  425:    // for this call without the cast to Element*:
        -:  426:    // function call '[testing::internal::NativeArray<char *>].NativeArray(
        -:  427:    //     {lval} const char *[4], long, testing::internal::RelationToSource)'
        -:  428:    //     does not match
        -:  429:    // 'testing::internal::NativeArray<char *>::NativeArray(
        -:  430:    //     char *const *, unsigned int, testing::internal::RelationToSource)'
        -:  431:    // (instantiating: 'testing::internal::ContainsMatcherImpl
        -:  432:    //     <const char * (&)[4]>::Matches(const char * (&)[4]) const')
        -:  433:    // (instantiating: 'testing::internal::StlContainerView<char *[4]>::
        -:  434:    //     ConstReference(const char * (&)[4])')
        -:  435:    // (and though the N parameter type is mismatched in the above explicit
        -:  436:    // conversion of it doesn't help - only the conversion of the array).
        -:  437:    return type(const_cast<Element*>(&array[0]), N, kReference);
        -:  438:#else
        -:  439:    return type(array, N, kReference);
        -:  440:#endif  // GTEST_OS_SYMBIAN
        -:  441:  }
        -:  442:  static type Copy(const Element (&array)[N]) {
        -:  443:#if GTEST_OS_SYMBIAN
        -:  444:    return type(const_cast<Element*>(&array[0]), N, kCopy);
        -:  445:#else
        -:  446:    return type(array, N, kCopy);
        -:  447:#endif  // GTEST_OS_SYMBIAN
        -:  448:  }
        -:  449:};
        -:  450:
        -:  451:// This specialization is used when RawContainer is a native array
        -:  452:// represented as a (pointer, size) tuple.
        -:  453:template <typename ElementPointer, typename Size>
        -:  454:class StlContainerView< ::std::tr1::tuple<ElementPointer, Size> > {
        -:  455: public:
        -:  456:  typedef GTEST_REMOVE_CONST_(
        -:  457:      typename internal::PointeeOf<ElementPointer>::type) RawElement;
        -:  458:  typedef internal::NativeArray<RawElement> type;
        -:  459:  typedef const type const_reference;
        -:  460:
        -:  461:  static const_reference ConstReference(
        -:  462:      const ::std::tr1::tuple<ElementPointer, Size>& array) {
        -:  463:    using ::std::tr1::get;
        -:  464:    return type(get<0>(array), get<1>(array), kReference);
        -:  465:  }
        -:  466:  static type Copy(const ::std::tr1::tuple<ElementPointer, Size>& array) {
        -:  467:    using ::std::tr1::get;
        -:  468:    return type(get<0>(array), get<1>(array), kCopy);
        -:  469:  }
        -:  470:};
        -:  471:
        -:  472:// The following specialization prevents the user from instantiating
        -:  473:// StlContainer with a reference type.
        -:  474:template <typename T> class StlContainerView<T&>;
        -:  475:
        -:  476:// A type transform to remove constness from the first part of a pair.
        -:  477:// Pairs like that are used as the value_type of associative containers,
        -:  478:// and this transform produces a similar but assignable pair.
        -:  479:template <typename T>
        -:  480:struct RemoveConstFromKey {
        -:  481:  typedef T type;
        -:  482:};
        -:  483:
        -:  484:// Partially specialized to remove constness from std::pair<const K, V>.
        -:  485:template <typename K, typename V>
        -:  486:struct RemoveConstFromKey<std::pair<const K, V> > {
        -:  487:  typedef std::pair<K, V> type;
        -:  488:};
        -:  489:
        -:  490:// Mapping from booleans to types. Similar to boost::bool_<kValue> and
        -:  491:// std::integral_constant<bool, kValue>.
        -:  492:template <bool kValue>
        -:  493:struct BooleanConstant {};
        -:  494:
        -:  495:}  // namespace internal
        -:  496:}  // namespace testing
        -:  497:
        -:  498:#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_
